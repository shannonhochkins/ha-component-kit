import { createCollection, type Connection, type HassEntities, type HassEntity } from "home-assistant-js-websocket";
import { LightColor } from "../types/autogenerated-types-by-domain";
import { computeDomain } from "./computeDomain";
import { EntityName, LocaleKeys } from "@typings";
import { computeEntityNameList, computeStateName } from "./entity";
import { AreaRegistryEntry, DeviceRegistryEntry, FloorRegistryEntry, localize } from "../hooks";
import { caseInsensitiveStringCompare } from "./string";
import { Store } from "home-assistant-js-websocket/dist/store.js";
import { debounce } from "lodash";

type EntityCategory = "config" | "diagnostic";

export interface RegistryEntry {
  created_at: number;
  modified_at: number;
}

export interface EntityRegistryDisplayEntry {
  entity_id: string;
  name?: string;
  icon?: string;
  device_id?: string;
  area_id?: string;
  labels: string[];
  hidden?: boolean;
  entity_category?: EntityCategory;
  translation_key?: string;
  platform?: string;
  display_precision?: number;
  has_entity_name?: boolean;
}

export interface EntityRegistryDisplayEntryResponse {
  entities: {
    ei: string;
    di?: string;
    ai?: string;
    lb: string[];
    ec?: number;
    en?: string;
    ic?: string;
    pl?: string;
    tk?: string;
    hb?: boolean;
    dp?: number;
    hn?: boolean;
  }[];
  entity_categories: Record<number, EntityCategory>;
}

export interface EntityRegistryEntry extends RegistryEntry {
  id: string;
  entity_id: string;
  name: string | null;
  icon: string | null;
  platform: string;
  config_entry_id: string | null;
  config_subentry_id: string | null;
  device_id: string | null;
  area_id: string | null;
  labels: string[];
  disabled_by: "user" | "device" | "integration" | "config_entry" | null;
  hidden_by: Exclude<EntityRegistryEntry["disabled_by"], "config_entry">;
  entity_category: EntityCategory | null;
  has_entity_name: boolean;
  original_name?: string;
  unique_id: string;
  translation_key?: string;
  options: EntityRegistryOptions | null;
  categories: Record<string, string>;
}

export interface ExtEntityRegistryEntry extends EntityRegistryEntry {
  capabilities: Record<string, unknown>;
  original_icon?: string;
  device_class?: string;
  original_device_class?: string;
  aliases: string[];
}

export interface UpdateEntityRegistryEntryResult {
  entity_entry: ExtEntityRegistryEntry;
  reload_delay?: number;
  require_restart?: boolean;
}

export interface SensorEntityOptions {
  display_precision?: number | null;
  suggested_display_precision?: number | null;
  unit_of_measurement?: string | null;
}

export interface LightEntityOptions {
  favorite_colors?: LightColor[];
}

export interface NumberEntityOptions {
  unit_of_measurement?: string | null;
}

export interface LockEntityOptions {
  default_code?: string | null;
}

export interface AlarmControlPanelEntityOptions {
  default_code?: string | null;
}

export interface WeatherEntityOptions {
  precipitation_unit?: string | null;
  pressure_unit?: string | null;
  temperature_unit?: string | null;
  visibility_unit?: string | null;
  wind_speed_unit?: string | null;
}

export interface SwitchAsXEntityOptions {
  entity_id: string;
  invert: boolean;
}

export interface EntityRegistryOptions {
  number?: NumberEntityOptions;
  sensor?: SensorEntityOptions;
  alarm_control_panel?: AlarmControlPanelEntityOptions;
  lock?: LockEntityOptions;
  weather?: WeatherEntityOptions;
  light?: LightEntityOptions;
  switch_as_x?: SwitchAsXEntityOptions;
  conversation?: Record<string, unknown>;
  "cloud.alexa"?: Record<string, unknown>;
  "cloud.google_assistant"?: Record<string, unknown>;
}

export interface EntityRegistryEntryUpdateParams {
  name?: string | null;
  icon?: string | null;
  device_class?: string | null;
  area_id?: string | null;
  disabled_by?: string | null;
  hidden_by: string | null;
  new_entity_id?: string;
  options_domain?: string;
  options?:
    | SensorEntityOptions
    | NumberEntityOptions
    | LockEntityOptions
    | AlarmControlPanelEntityOptions
    | WeatherEntityOptions
    | LightEntityOptions;
  aliases?: string[];
  labels?: string[];
  categories?: Record<string, string | null>;
}

const batteryPriorities = ["sensor", "binary_sensor"];
/**
 * Find the most relevant battery entity from a list of registry display entries.
 *
 * Prioritization order is defined in `batteryPriorities` (sensor > binary_sensor).
 * A matching entity must have `attributes.device_class === "battery"` and its domain
 * must appear in the priorities list. The first item after sorting by domain priority is returned.
 *
 * @template T extends object containing an `entity_id` field.
 * @param hassEntities Full Home Assistant entity state map.
 * @param entities Candidate list (typically registry entries or simplified objects with entity_id).
 * @returns The highest priority battery entity or `undefined` if none match.
 */
export const findBatteryEntity = <T extends { entity_id: string }>(hassEntities: HassEntities, entities: T[]): T | undefined => {
  const batteryEntities = entities
    .filter(
      (entity) =>
        hassEntities[entity.entity_id] &&
        hassEntities[entity.entity_id].attributes.device_class === "battery" &&
        batteryPriorities.includes(computeDomain(entity.entity_id as EntityName)),
    )
    .sort(
      (a, b) =>
        batteryPriorities.indexOf(computeDomain(a.entity_id as EntityName)) -
        batteryPriorities.indexOf(computeDomain(b.entity_id as EntityName)),
    );
  if (batteryEntities.length > 0) {
    return batteryEntities[0];
  }

  return undefined;
};

/**
 * Locate a battery charging entity (device_class === "battery_charging") in the provided list.
 * Returns the first match; no domain prioritization is applied.
 *
 * @template T extends object containing an `entity_id` field.
 * @param hassEntities Full HA entity state map.
 * @param entities Candidate list.
 * @returns A matching charging entity or `undefined` if not found.
 */
export const findBatteryChargingEntity = <T extends { entity_id: string }>(hassEntities: HassEntities, entities: T[]): T | undefined =>
  entities.find(
    (entity) => hassEntities[entity.entity_id] && hassEntities[entity.entity_id].attributes.device_class === "battery_charging",
  );

/**
 * Compute a human readable name for an entity registry entry.
 *
 * Resolution order:
 * 1. Explicit `entry.name`
 * 2. Derived friendly state name (via `computeStateName`)
 * 3. Original name (`entry.original_name`) or fallback to `entry.entity_id`.
 *
 * @param hassEntities Full HA entity state map.
 * @param entry The registry entry we want to name.
 * @returns Resolved name or `null` if not determinable.
 */
export const computeEntityRegistryName = (hassEntities: HassEntities, entry: EntityRegistryEntry): string | null => {
  if (entry.name) {
    return entry.name;
  }
  const state = hassEntities[entry.entity_id];
  if (state) {
    return computeStateName(state);
  }
  return entry.original_name ? entry.original_name : entry.entity_id;
};

/**
 * Fetch a single extended entity registry entry from Home Assistant.
 *
 * This issues a WebSocket command (`config/entity_registry/get`) via `sendMessagePromise`.
 *
 * @param connection Active HA websocket connection.
 * @param entityId Target entity_id to retrieve extended registry info for.
 * @returns Promise resolving to the extended registry entry.
 */
export const getExtendedEntityRegistryEntry = (connection: Connection, entityId: string): Promise<ExtEntityRegistryEntry> =>
  connection.sendMessagePromise<ExtEntityRegistryEntry>({
    type: "config/entity_registry/get",
    entity_id: entityId,
  });

/**
 * Fetch multiple extended entity registry entries in a single request.
 *
 * Issues `config/entity_registry/get_entries` with an array of ids.
 *
 * @param connection Active HA websocket connection.
 * @param entityIds Array of entity_ids to fetch.
 * @returns Promise resolving to a keyed record (entity_id -> extended entry).
 */
export const getExtendedEntityRegistryEntries = (
  connection: Connection,
  entityIds: string[],
): Promise<Record<string, ExtEntityRegistryEntry>> =>
  connection.sendMessagePromise<Record<string, ExtEntityRegistryEntry>>({
    type: "config/entity_registry/get_entries",
    entity_ids: entityIds,
  });

/**
 * Update an existing entity registry entry.
 *
 * Issues `config/entity_registry/update` with partial update fields.
 * Supports renaming, area assignment, icon/device_class changes, and options updates.
 *
 * @param connection HA websocket connection.
 * @param entityId Target entity_id.
 * @param updates Partial set of fields to update.
 * @returns Promise resolving to the update result (may include restart or reload hints).
 */
export const updateEntityRegistryEntry = (
  connection: Connection,
  entityId: string,
  updates: Partial<EntityRegistryEntryUpdateParams>,
): Promise<UpdateEntityRegistryEntryResult> =>
  connection.sendMessagePromise<UpdateEntityRegistryEntryResult>({
    type: "config/entity_registry/update",
    entity_id: entityId,
    ...updates,
  });

/**
 * Remove an entity from the registry (may not remove underlying integration/device).
 *
 * Issues `config/entity_registry/remove`.
 *
 * @param connection HA websocket connection.
 * @param entityId The entity_id to remove.
 * @returns Promise resolving when removal is acknowledged.
 */
export const removeEntityRegistryEntry = (connection: Connection, entityId: string): Promise<void> =>
  connection.sendMessagePromise<void>({
    type: "config/entity_registry/remove",
    entity_id: entityId,
  });

/**
 * Retrieve compact display-friendly registry entries.
 *
 * Issues `config/entity_registry/list_for_display`, returning a structure optimized
 * for UI listing (with short keys and separate category mapping).
 *
 * @param connection HA websocket connection.
 * @returns Promise resolving to display entry response payload.
 */
export const fetchEntityRegistryDisplay = (connection: Connection) =>
  connection.sendMessagePromise<EntityRegistryDisplayEntryResponse>({
    type: "config/entity_registry/list_for_display",
  });

const subscribeEntityRegistryDisplayUpdates = (conn: Connection, store: Store<EntityRegistryDisplayEntryResponse>) =>
  conn.subscribeEvents(
    debounce(() => fetchEntityRegistryDisplay(conn).then((entities) => store.setState(entities, true)), 500, {
      leading: true,
      trailing: true,
    }),
    "entity_registry_updated",
  );

export const subscribeEntityRegistryDisplay = (conn: Connection, onChange: (entities: EntityRegistryDisplayEntryResponse) => void) =>
  createCollection<EntityRegistryDisplayEntryResponse>(
    "_entityRegistryDisplay",
    fetchEntityRegistryDisplay,
    subscribeEntityRegistryDisplayUpdates,
    conn,
    onChange,
  );

/**
 * Sort registry entries by their explicit name (locale-aware case-insensitive).
 *
 * @param entries Registry entries array (mutated in place by Array.sort).
 * @param language Locale/language code for comparison rules.
 * @returns The same array reference sorted.
 */
export const sortEntityRegistryByName = (entries: EntityRegistryEntry[], language: string) =>
  entries.sort((entry1, entry2) => caseInsensitiveStringCompare(entry1.name || "", entry2.name || "", language));

/**
 * Build a lookup map keyed by `entity_id` for quick access.
 *
 * @param entries Array of registry entries.
 * @returns Record mapping entity_id -> entry.
 */
export const entityRegistryByEntityId = (entries: EntityRegistryEntry[]) => {
  const entities: Record<string, EntityRegistryEntry> = {};
  for (const entity of entries) {
    entities[entity.entity_id] = entity;
  }
  return entities;
};

/**
 * Build a lookup map keyed by internal registry `id`.
 *
 * @param entries Array of registry entries.
 * @returns Record mapping registry id -> entry.
 */
export const entityRegistryById = (entries: EntityRegistryEntry[]) => {
  const entities: Record<string, EntityRegistryEntry> = {};
  for (const entity of entries) {
    entities[entity.id] = entity;
  }
  return entities;
};

/**
 * Produce a mapping from entity_id to integration platform name.
 * Ignores entries lacking a platform.
 *
 * @param entities Registry entries.
 * @returns Record entity_id -> platform string.
 */
export const getEntityPlatformLookup = (entities: EntityRegistryEntry[]): Record<string, string> => {
  const entityLookup: Record<string, string> = {};
  for (const confEnt of entities) {
    if (!confEnt.platform) {
      continue;
    }
    entityLookup[confEnt.entity_id] = confEnt.platform;
  }
  return entityLookup;
};

/**
 * Ask Home Assistant for automatically suggested entity_ids for given IDs.
 *
 * Issues `config/entity_registry/get_automatic_entity_ids`.
 *
 * @param connection HA websocket connection.
 * @param entity_ids List of entity IDs to query.
 * @returns Promise resolving to a mapping of original id -> suggested new id (or null).
 */
export const getAutomaticEntityIds = (connection: Connection, entity_ids: string[]) =>
  connection.sendMessagePromise<Record<string, string | null>>({
    type: "config/entity_registry/get_automatic_entity_ids",
    entity_ids,
  });

export interface EntityListInfoCommon {
  id: string;
  primary: string;
  secondary?: string;
  search_labels?: string[];
  sorting_label?: string;
  icon_path?: string;
  icon?: string;
}

export interface EntityListInfo extends EntityListInfoCommon {
  domain_name?: string;
  stateObj?: HassEntity;
}

/**
 * Build a filtered & decorated list of entity metadata for UI consumption.
 *
 * Applies domain/entity include & exclude filters, device class filtering, unit filtering,
 * custom predicate filtering, and search label composition. Produces a stable list of
 * `EntityListInfo` objects with primary/secondary labels.
 *
 * @param hassEntities Raw HA entities state map.
 * @param entities Display registry entry map (entity_id -> display entry) used for name resolution.
 * @param devices Device registry map (device_id -> device entry) for hierarchical naming.
 * @param areas Area registry map (area_id -> area entry) for hierarchical naming.
 * @param floors Floor registry map (floor_id -> floor entry) for hierarchical naming.
 * @param includeDomains Domains to explicitly include (optional).
 * @param excludeDomains Domains to explicitly exclude (optional).
 * @param entityFilter Additional predicate applied to each HassEntity (optional).
 * @param includeDeviceClasses Device classes to include (optional).
 * @param includeUnitOfMeasurement Units of measurement to include (optional).
 * @param includeEntities Explicit entity_ids to include (optional).
 * @param excludeEntities Explicit entity_ids to exclude (optional).
 * @param value A selected value whose entity should always be retained in filtering (optional).
 * @param idPrefix Prefix applied to generated `id` field (defaults to '').
 * @returns Filtered, mapped array of `EntityListInfo` objects.
 */
export const getEntities = (
  hassEntities: HassEntities,
  entities: Record<string, EntityRegistryDisplayEntry>,
  devices: Record<string, DeviceRegistryEntry>,
  areas: Record<string, AreaRegistryEntry>,
  floors: Record<string, FloorRegistryEntry>,
  includeDomains?: string[],
  excludeDomains?: string[],
  entityFilter?: (entityId: HassEntity) => boolean,
  includeDeviceClasses?: string[],
  includeUnitOfMeasurement?: string[],
  includeEntities?: string[],
  excludeEntities?: string[],
  value?: string,
  idPrefix = "",
): EntityListInfo[] => {
  let items: EntityListInfo[] = [];

  let entityIds = Object.keys(hassEntities);

  if (includeEntities) {
    entityIds = entityIds.filter((entityId) => includeEntities.includes(entityId));
  }

  if (excludeEntities) {
    entityIds = entityIds.filter((entityId) => !excludeEntities.includes(entityId));
  }

  if (includeDomains) {
    entityIds = entityIds.filter((eid) => includeDomains.includes(computeDomain(eid as EntityName)));
  }

  if (excludeDomains) {
    entityIds = entityIds.filter((eid) => !excludeDomains.includes(computeDomain(eid as EntityName)));
  }

  items = entityIds.map<EntityListInfo>((entityId) => {
    const stateObj = hassEntities[entityId];

    const friendlyName = computeStateName(stateObj); // Keep this for search
    const [entityName, deviceName, areaName] = computeEntityNameList(
      stateObj,
      [{ type: "entity" }, { type: "device" }, { type: "area" }],
      entities,
      devices,
      areas,
      floors,
    );
    const domain = computeDomain(entityId as EntityName);
    const domainName = localize(`${domain}.title` as LocaleKeys, {
      fallback: localize(domain as LocaleKeys),
    });

    const primary = entityName || deviceName || entityId;
    const secondary = [areaName, entityName ? deviceName : undefined].filter(Boolean).join(" â–¸ ");

    return {
      id: `${idPrefix}${entityId}`,
      primary: primary,
      secondary: secondary,
      domain_name: domainName,
      sorting_label: [deviceName, entityName].filter(Boolean).join("_"),
      search_labels: [entityName, deviceName, areaName, domainName, friendlyName, entityId].filter(Boolean) as string[],
      stateObj: stateObj,
    };
  });

  if (includeDeviceClasses) {
    items = items.filter(
      (item) =>
        // We always want to include the entity of the current value
        item.id === value ||
        (item.stateObj?.attributes.device_class && includeDeviceClasses.includes(item.stateObj.attributes.device_class)),
    );
  }

  if (includeUnitOfMeasurement) {
    items = items.filter(
      (item) =>
        // We always want to include the entity of the current value
        item.id === value ||
        (item.stateObj?.attributes.unit_of_measurement && includeUnitOfMeasurement.includes(item.stateObj.attributes.unit_of_measurement)),
    );
  }

  if (entityFilter) {
    items = items.filter(
      (item) =>
        // We always want to include the entity of the current value
        item.id === value || (item.stateObj && entityFilter!(item.stateObj)),
    );
  }

  return items;
};
